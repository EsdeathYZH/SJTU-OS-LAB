Q1:Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?

A:我不需要做一些额外的事情，因为我将权限位存储在env的trapframe中，而每次环境的进入与退出都会重新加载与保存这个trapframe的状态。所以每次环境的切换都会自动帮助我们加载正确的权限位。

How to solve challenge?

A:现有的设计有一个致命的缺陷，就是我们没有驱逐block的机制，这样的话随着系统的运行，我们会不断地将块从磁盘加载到内存中，内存空间会不断缩小直到0，所以我们需要实现一个合理的驱逐块函数。这也是我完成的challenge内容，我的驱逐逻辑也不是很复杂：当分配一个新块时判断是否达到了evict阈值需要调用evict函数，在evict函数中首先遍历所有除Block0，Block1之外的没有被访问过的内存页，不断的evict这些页直到达到每次evict的数目，如果驱逐了所有未被访问的页还没有达到，就需要降级驱逐那些被访问过的页。由于这次的测试用例覆盖的块比较少，所以我暂时将evict阈值设置为30，每次evict 2个block，这样在调用testfile用例时就可以触发到evict函数。调用make run-testfile，可以看到evict被成功调用并且用例通过运行，证明实现是正确的，为了之后的运行性能，我暂时将阈值和驱逐数调整为更加合理的值：16*1024 (64MB)和64。
evict函数如下：
void 
evict_block()
{
	//Every time we evict evict_batch_size blocks
	int r;
	uint32_t evict_block_num = 0;
	uint32_t evict_batch_size = 2;
	for(uintptr_t addr = DISKMAP+2*PGSIZE; addr < DISKSIZE+DISKMAP; addr += PGSIZE){
		if(va_is_mapped((void*)addr) && (uvpt[PGNUM(addr)] & PTE_A)==0){
			if(va_is_dirty((void*)addr)){
				flush_block((void*)addr);
			}
			if((r = sys_page_unmap(0, (void*)addr)) < 0){
				panic("sys_page_unmap: %e", r);
			}
			assert(!va_is_mapped((void*)addr));
			evict_block_num++;
			//cprintf("Evict unaccessed block is successful!!\n");
			if(evict_block_num >= evict_batch_size) break;
		}
	}
	if(evict_block_num < evict_batch_size){
		for(uintptr_t addr = DISKMAP+2*PGSIZE; addr < DISKSIZE+DISKMAP; addr += PGSIZE){
			if(va_is_mapped((void*)addr)){
				if(va_is_dirty((void*)addr)){
					flush_block((void*)addr);
				}
				if((r = sys_page_unmap(0, (void*)addr)) < 0){
					panic("sys_page_unmap: %e", r);
				}
				assert(!va_is_mapped((void*)addr));
				evict_block_num++;
				//cprintf("Evict accessed block is successful!!\n");
				if(evict_block_num >= evict_batch_size) break;
			}
		}
	}
	//impossible
	if(evict_block_num < evict_batch_size){
		assert(false);
	}
	cprintf("Evict block is successful!!\n");
	allocated_block_num -= evict_block_num;
}

